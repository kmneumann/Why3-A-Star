module ImpmapNoDom

  use map.Map
  use map.Const

  type key

  type myMap 'a = abstract { mutable contents: map key 'a }

  val function create (x: 'a): myMap 'a
    ensures { result.contents = const x }

  val function ([]) (m: myMap 'a) (k: key): 'a
    ensures { result = m.contents[k] }

  val ghost function ([<-]) (m: myMap 'a) (k: key) (v: 'a): myMap 'a
    ensures { result.contents = m.contents[k <- v] }

  val ([]<-) (m: myMap 'a) (k: key) (v: 'a): unit
    writes { m }
    ensures { m = (old m)[k <- v] }

end


module Heuristic

  clone export GraphsAndOptimalPaths  
  
  
  val function optimal_h (n dst: node) : int
    requires { Fset.mem n nodes /\ Fset.mem dst nodes }
    ensures { result >= 0 } 
    ensures { forall l: list node. optimal_path l n dst -> result = path_weight l }
  
  val function h (n: node) : int
    requires { Fset.mem n nodes }
    ensures { result >= 0 } 
    
  (*
  predicate admissible (f: node -> int) (dst: node) = 
      forall src: node, l: list node. optimal_path l src dst -> path_weight l >= f src
  *)
  
  predicate admissible (f: node -> int) (dst: node) = 
      forall src: node. f src <= optimal_h src dst
  
  predicate monotonic_acorss_edge (f: node -> int)  (u v: node) = 
      edge u v -> f u <= weight u v + f v
      
  predicate monotonic_acorss_path (f: node -> int)  (l: list node) = 
      match l with
          | Nil -> true
          | Cons _ Nil -> true
          | Cons x ((Cons y _) as t) -> monotonic_acorss_edge f x y /\ monotonic_acorss_path f t
      end
  
  predicate monotonic (f: node -> int) = 
      forall u v: node. monotonic_acorss_edge f u v
  
  lemma weaker_consistancy_across_path :
      forall l: list node. monotonic h -> monotonic_acorss_path h l
  
  lemma consistancy_implies_consistancy_across_path :
      forall src dst: node, l: list node. monotonic h -> path l src dst -> monotonic_acorss_path h l
  
  lemma consistancy_lower_estimate :
      forall src dst: node, l: list node. path l src dst -> h dst = 0 -> monotonic_acorss_path h l -> path_weight l >= h src
  
  lemma consistancy_implies_admissibility:
      forall dst: node. monotonic h -> h dst = 0 -> admissible h dst
  
end


module MyProof

  use int.Int
  use int.Abs
  use ref.Ref
  use list.List
  use option.Option
  use map.Map
  
  
  type node 
  
  clone set.SetImp with type elt = node
  clone ImpmapNoDom with type key = node
  
  constant nodes: fset node 
  
  val function weight (a b: node) : int
    ensures { result >= 0 }
    ensures { a = b -> result = 0 }
    
  val ghost function successor (a: node) : fset node
    requires { mem a nodes }
    ensures { subset result nodes }
  
  val successors node : set
    ensures { subset result nodes }
  
  predicate edge (a b: node) = mem b (successor a)
  
  clone export graph.IntPathWeight with type vertex = node, val weight = weight, predicate edge = edge
  
  predicate accessible (a b: node) = 
    exists l. path a l b
  
  predicate optimal_path (src: node) (steps: list node) (dst: node) = 
    path src steps dst /\
    (forall l: list node. path src l dst -> path_weight l dst >= path_weight steps dst)
  
  lemma LengthNonneg: 
    forall x y: node, l: list node. path x l y -> path_weight l y >= 0
    
  lemma NoShorterPathToSelf:
    forall x: node, l: list node. path x l x -> path_weight l x >= path_weight Nil x
    
  lemma OptimalPathToSelf: 
    forall x: node, l: list node. optimal_path x l x -> path_weight l x = 0
    
  lemma OptimalPathIsShortest:
    forall a b: node, l l': list node. 
      optimal_path a l b -> path a l' b -> path_weight l b <= path_weight l' b
      
  lemma PathBoundsOptimal:
    forall a b: node, l l': list node. 
      path a l b -> optimal_path a l' b -> path_weight l' b <= path_weight l b
  
  lemma PathImpliesOptimalExists:
    forall a b: node. (exists l: list node. path a l b) -> (exists l': list node. optimal_path a l' b)
      
  predicate admissible (f: node -> int) (dst: node) = 
    forall src: node, l: list node. optimal_path src l dst -> path_weight l src >= f src
  
  predicate monotonic (f: node -> int) = 
    forall u v: node. mem v (successor u) ->
      f u <= weight u v + f v
      
  predicate all_positive (f: node -> int) = 
    forall u: node. f u >= 0
  
  val g : myMap int
  
  val ghost function heuristic node : int
  val function h (n: node) : int
    requires { monotonic heuristic }
    requires { all_positive heuristic }
    ensures { result = heuristic n } 
  
  lemma ConsistancyImpliesAdmissibility:
    forall dst: node. admissible h dst
  
  val openSet: set
  val closedSet: set
  
  predicate min (m: node) (q: set) (g: myMap int) (h: node -> int) =
    mem m q /\
    forall x: node. mem x q -> g[m] + h m  <= g[x] + h x
  
  val get_next_node () : node
    writes { openSet, closedSet }
    ensures { min result (old openSet) g h }
    ensures { openSet = remove result (old openSet) }
    ensures { closedSet = add result (old closedSet) } 
    
  val init (src: node) : unit 
    writes { openSet, closedSet, g}
    ensures { openSet = singleton src }
    ensures { is_empty closedSet }
    ensures { g = (old g)[src <- 0] }
  
  let a_star_search (src dst: node) : option (list node) =
    requires { mem src nodes }
    requires { mem dst nodes }
    requires { h dst = 0 }
    ensures { result = None -> forall x. not (path src x dst) }
    ensures { forall l: list node. result = Some l -> optimal_path src l dst } 
    init src;
    let result = ref None in
    while not (is_empty openSet) do
      variant { cardinal nodes - cardinal closedSet }
      let current = get_next_node () in
      if eq current dst then result := None else
        let neighbours = successors current in 
        while not (is_empty neighbours) do
          variant { cardinal neighbours }
          let neighbour = choose_and_remove neighbours in 
          if not (mem neighbour closedSet) then add neighbour openSet
        done
    done;
    !result
end
