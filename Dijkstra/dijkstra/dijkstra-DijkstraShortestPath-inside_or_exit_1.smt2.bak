;;; generated by SMT-LIB2 driver
;;; SMT-LIB2 driver: bit-vectors, common part
;;; generated by SMT-LIB strings
;;; SMT-LIB2: integer arithmetic
(declare-sort uni 0)

(declare-sort ty 0)

;; "sort"
(declare-fun sort (ty
  uni) Bool)

;; "witness"
(declare-fun witness (ty) uni)

;; "witness_sort"
(assert (forall ((a ty)) (sort a (witness a))))

;; "int"
(declare-fun int () ty)

;; "bool"
(declare-fun bool () ty)

;; "list"
(declare-fun list (ty) ty)

;; "Nil"
(declare-fun Nil (ty) uni)

;; "Nil_sort"
(assert (forall ((a ty)) (sort (list a) (Nil a))))

;; "Cons"
(declare-fun Cons (ty
  uni
  uni) uni)

;; "Cons_sort"
(assert
  (forall ((a ty)) (forall ((x uni) (x1 uni)) (sort (list a) (Cons a x x1)))))

;; "match_list"
(declare-fun match_list (ty
  ty
  uni
  uni
  uni) uni)

;; "match_list_sort"
(assert
  (forall ((a ty) (a1 ty))
    (forall ((x uni) (x1 uni) (x2 uni)) (sort a1 (match_list a1 a x x1 x2)))))

;; "match_list_Nil"
(assert
  (forall ((a ty) (a1 ty))
    (forall ((z uni) (z1 uni))
      (=> (sort a1 z) (= (match_list a1 a (Nil a) z z1) z)))))

;; "match_list_Cons"
(assert
  (forall ((a ty) (a1 ty))
    (forall ((z uni) (z1 uni) (u uni) (u1 uni))
      (=> (sort a1 z1) (= (match_list a1 a (Cons a u u1) z z1) z1)))))

;; "index_list"
(declare-fun index_list (ty
  uni) Int)

;; "index_list_Nil"
(assert (forall ((a ty)) (= (index_list a (Nil a)) 0)))

;; "index_list_Cons"
(assert
  (forall ((a ty))
    (forall ((u uni) (u1 uni))
      (! (= (index_list a (Cons a u u1)) 1) :pattern ((Cons a u u1)) ))))

;; "Cons_proj_1"
(declare-fun Cons_proj_1 (ty
  uni) uni)

;; "Cons_proj_1_sort"
(assert (forall ((a ty)) (forall ((x uni)) (sort a (Cons_proj_1 a x)))))

;; "Cons_proj_1'def"
(assert
  (forall ((a ty))
    (forall ((u uni) (u1 uni))
      (=> (sort a u) (= (Cons_proj_1 a (Cons a u u1)) u)))))

;; "Cons_proj_2"
(declare-fun Cons_proj_2 (ty
  uni) uni)

;; "Cons_proj_2_sort"
(assert
  (forall ((a ty)) (forall ((x uni)) (sort (list a) (Cons_proj_2 a x)))))

;; "Cons_proj_2'def"
(assert
  (forall ((a ty))
    (forall ((u uni) (u1 uni)) (= (Cons_proj_2 a (Cons a u u1)) u1))))

;; "list_inversion"
(assert
  (forall ((a ty))
    (forall ((u uni))
      (or (= u (Nil a)) (= u (Cons a (Cons_proj_1 a u) (Cons_proj_2 a u)))))))

(declare-sort vertex 0)

;; "vertex"
(declare-fun vertex1 () ty)

(declare-sort fset 1)

;; "fset"
(declare-fun fset1 (ty) ty)

;; "infix ->"
(declare-fun infix_mngt (ty
  ty) ty)

(declare-sort set 0)

;; "set"
(declare-fun set1 () ty)

;; "length"
(declare-fun length (ty
  uni) Int)

;; "length'def"
(assert
  (forall ((a ty))
    (and
      (= (length a (Nil a)) 0)
      (forall ((x uni) (x1 uni))
        (= (length a (Cons a x x1)) (+ 1 (length a x1)))))))

;; "Length_nonnegative"
(assert (forall ((a ty)) (forall ((l uni)) (<= 0 (length a l)))))

;; "Length_nil"
(assert
  (forall ((a ty)) (forall ((l uni)) (= (= (length a l) 0) (= l (Nil a))))))

;; "mem"
(declare-fun mem (ty
  uni
  uni) Bool)

;; "mem'def"
(assert
  (forall ((a ty))
    (forall ((x uni))
      (=>
        (sort a x)
        (and
          (not (mem a x (Nil a)))
          (forall ((y uni) (r uni))
            (=>
              (sort a y)
              (= (mem a x (Cons a y r)) (or (= x y) (mem a x r))))))))))

;; "hd"
(declare-fun hd (ty
  uni) uni)

;; "hd_sort"
(assert (forall ((a ty)) (forall ((x uni)) (sort a (hd a x)))))

;; "hd_cons"
(assert
  (forall ((a ty))
    (forall ((x uni) (r uni)) (=> (sort a x) (= (hd a (Cons a x r)) x)))))

;; "tl"
(declare-fun tl (ty
  uni) uni)

;; "tl_sort"
(assert (forall ((a ty)) (forall ((x uni)) (sort (list a) (tl a x)))))

;; "tl_cons"
(assert
  (forall ((a ty)) (forall ((x uni) (r uni)) (= (tl a (Cons a x r)) r))))

;; "infix ++"
(declare-fun infix_plpl (ty
  uni
  uni) uni)

;; "infix ++_sort"
(assert
  (forall ((a ty))
    (forall ((x uni) (x1 uni)) (sort (list a) (infix_plpl a x x1)))))

;; "infix ++'def"
(assert
  (forall ((a ty))
    (forall ((l2 uni))
      (and
        (= (infix_plpl a (Nil a) l2) l2)
        (forall ((x1 uni) (r1 uni))
          (= (infix_plpl a (Cons a x1 r1) l2) (Cons
                                                a
                                                x1
                                                (infix_plpl a r1 l2))))))))

;; "Append_assoc"
(assert
  (forall ((a ty))
    (forall ((l1 uni) (l2 uni) (l3 uni))
      (= (infix_plpl a l1 (infix_plpl a l2 l3)) (infix_plpl
                                                  a
                                                  (infix_plpl a l1 l2)
                                                  l3)))))

;; "Append_l_nil"
(assert (forall ((a ty)) (forall ((l uni)) (= (infix_plpl a l (Nil a)) l))))

;; "Append_length"
(assert
  (forall ((a ty))
    (forall ((l1 uni) (l2 uni))
      (= (length a (infix_plpl a l1 l2)) (+ (length a l1) (length a l2))))))

;; "mem_append"
(assert
  (forall ((a ty))
    (forall ((x uni) (l1 uni) (l2 uni))
      (= (mem a x (infix_plpl a l1 l2)) (or (mem a x l1) (mem a x l2))))))

;; "mem_decomp"
(assert
  (forall ((a ty))
    (forall ((x uni) (l uni))
      (=>
        (mem a x l)
        (exists ((l1 uni) (l2 uni))
          (and
            (sort (list a) l1)
            (and (sort (list a) l2) (= l (infix_plpl a l1 (Cons a x l2))))))))))

;; "mem"
(declare-fun mem1 (ty
  uni
  uni) Bool)

;; "mem"
(declare-fun mem2 (vertex
  (fset vertex)) Bool)

;; "infix =="
(declare-fun infix_eqeq (ty
  uni
  uni) Bool)

;; "t2tb"
(declare-fun t2tb ((fset vertex)) uni)

;; "t2tb_sort"
(assert (forall ((x (fset vertex))) (sort (fset1 vertex1) (t2tb x))))

;; "tb2t"
(declare-fun tb2t (uni) (fset vertex))

;; "BridgeL"
(assert
  (forall ((i (fset vertex))) (! (= (tb2t (t2tb i)) i) :pattern ((t2tb i)) )))

;; "BridgeR"
(assert
  (forall ((j uni))
    (! (=> (sort (fset1 vertex1) j) (= (t2tb (tb2t j)) j)) :pattern (
    (t2tb
      (tb2t j))) )))

;; "infix =='def"
(assert
  (forall ((s1 (fset vertex)) (s2 (fset vertex)))
    (=
      (infix_eqeq vertex1 (t2tb s1) (t2tb s2))
      (forall ((x vertex)) (= (mem2 x s1) (mem2 x s2))))))

;; "infix =='def"
(assert
  (forall ((a ty))
    (forall ((s1 uni) (s2 uni))
      (and
        (=>
          (infix_eqeq a s1 s2)
          (forall ((x uni)) (= (mem1 a x s1) (mem1 a x s2))))
        (=>
          (forall ((x uni)) (=> (sort a x) (= (mem1 a x s1) (mem1 a x s2))))
          (infix_eqeq a s1 s2))))))

;; "extensionality"
(assert
  (forall ((a ty))
    (forall ((s1 uni) (s2 uni))
      (=>
        (sort (fset1 a) s1)
        (=> (sort (fset1 a) s2) (=> (infix_eqeq a s1 s2) (= s1 s2)))))))

;; "subset"
(declare-fun subset1 (ty
  uni
  uni) Bool)

;; "subset'def"
(assert
  (forall ((s1 (fset vertex)) (s2 (fset vertex)))
    (=
      (subset1 vertex1 (t2tb s1) (t2tb s2))
      (forall ((x vertex)) (=> (mem2 x s1) (mem2 x s2))))))

;; "subset'def"
(assert
  (forall ((a ty))
    (forall ((s1 uni) (s2 uni))
      (and
        (=>
          (subset1 a s1 s2)
          (forall ((x uni)) (=> (mem1 a x s1) (mem1 a x s2))))
        (=>
          (forall ((x uni)) (=> (sort a x) (=> (mem1 a x s1) (mem1 a x s2))))
          (subset1 a s1 s2))))))

;; "subset_refl"
(assert (forall ((a ty)) (forall ((s uni)) (subset1 a s s))))

;; "subset_trans"
(assert
  (forall ((a ty))
    (forall ((s1 uni) (s2 uni) (s3 uni))
      (=> (subset1 a s1 s2) (=> (subset1 a s2 s3) (subset1 a s1 s3))))))

;; "is_empty"
(declare-fun is_empty (ty
  uni) Bool)

;; "is_empty'def"
(assert
  (forall ((s (fset vertex)))
    (= (is_empty vertex1 (t2tb s)) (forall ((x vertex)) (not (mem2 x s))))))

;; "is_empty'def"
(assert
  (forall ((a ty))
    (forall ((s uni))
      (and
        (=> (is_empty a s) (forall ((x uni)) (not (mem1 a x s))))
        (=>
          (forall ((x uni)) (=> (sort a x) (not (mem1 a x s))))
          (is_empty a s))))))

;; "empty"
(declare-fun empty (ty) uni)

;; "empty_sort"
(assert (forall ((a ty)) (sort (fset1 a) (empty a))))

;; "is_empty_empty"
(assert (forall ((a ty)) (is_empty a (empty a))))

;; "empty_is_empty"
(assert
  (forall ((a ty))
    (forall ((s uni))
      (=> (sort (fset1 a) s) (=> (is_empty a s) (= s (empty a)))))))

;; "add"
(declare-fun add (ty
  uni
  uni) uni)

;; "add_sort"
(assert
  (forall ((a ty)) (forall ((x uni) (x1 uni)) (sort (fset1 a) (add a x x1)))))

;; "t2tb"
(declare-fun t2tb1 (vertex) uni)

;; "t2tb_sort"
(assert (forall ((x vertex)) (sort vertex1 (t2tb1 x))))

;; "tb2t"
(declare-fun tb2t1 (uni) vertex)

;; "BridgeL"
(assert
  (forall ((i vertex)) (! (= (tb2t1 (t2tb1 i)) i) :pattern ((t2tb1 i)) )))

;; "BridgeR"
(assert
  (forall ((j uni))
    (! (=> (sort vertex1 j) (= (t2tb1 (tb2t1 j)) j)) :pattern ((t2tb1
                                                                 (tb2t1 j))) )))

;; "add_def"
(assert
  (forall ((x vertex) (s (fset vertex)) (y vertex))
    (=
      (mem2 y (tb2t (add vertex1 (t2tb1 x) (t2tb s))))
      (or (mem2 y s) (= y x)))))

;; "add_def"
(assert
  (forall ((a ty))
    (forall ((x uni) (s uni) (y uni))
      (=>
        (sort a x)
        (=> (sort a y) (= (mem1 a y (add a x s)) (or (mem1 a y s) (= y x))))))))

;; "mem_singleton"
(assert
  (forall ((x vertex) (y vertex))
    (=> (mem2 y (tb2t (add vertex1 (t2tb1 x) (empty vertex1)))) (= y x))))

;; "mem_singleton"
(assert
  (forall ((a ty))
    (forall ((x uni) (y uni))
      (=>
        (sort a x)
        (=> (sort a y) (=> (mem1 a y (add a x (empty a))) (= y x)))))))

;; "remove"
(declare-fun remove (ty
  uni
  uni) uni)

;; "remove_sort"
(assert
  (forall ((a ty))
    (forall ((x uni) (x1 uni)) (sort (fset1 a) (remove a x x1)))))

;; "remove_def"
(assert
  (forall ((x vertex) (s (fset vertex)) (y vertex))
    (=
      (mem2 y (tb2t (remove vertex1 (t2tb1 x) (t2tb s))))
      (and (mem2 y s) (not (= y x))))))

;; "remove_def"
(assert
  (forall ((a ty))
    (forall ((x uni) (s uni) (y uni))
      (=>
        (sort a x)
        (=>
          (sort a y)
          (= (mem1 a y (remove a x s)) (and (mem1 a y s) (not (= y x)))))))))

;; "add_remove"
(assert
  (forall ((x vertex) (s (fset vertex)))
    (=>
      (mem2 x s)
      (= (tb2t (add vertex1 (t2tb1 x) (remove vertex1 (t2tb1 x) (t2tb s)))) s))))

;; "add_remove"
(assert
  (forall ((a ty))
    (forall ((x uni) (s uni))
      (=>
        (sort (fset1 a) s)
        (=> (mem1 a x s) (= (add a x (remove a x s)) s))))))

;; "remove_add"
(assert
  (forall ((a ty))
    (forall ((x uni) (s uni)) (= (remove a x (add a x s)) (remove a x s)))))

;; "subset_remove"
(assert
  (forall ((a ty)) (forall ((x uni) (s uni)) (subset1 a (remove a x s) s))))

;; "union"
(declare-fun union1 (ty
  uni
  uni) uni)

;; "union_sort"
(assert
  (forall ((a ty))
    (forall ((x uni) (x1 uni)) (sort (fset1 a) (union1 a x x1)))))

;; "union_def"
(assert
  (forall ((s1 (fset vertex)) (s2 (fset vertex)) (x vertex))
    (=
      (mem2 x (tb2t (union1 vertex1 (t2tb s1) (t2tb s2))))
      (or (mem2 x s1) (mem2 x s2)))))

;; "union_def"
(assert
  (forall ((a ty))
    (forall ((s1 uni) (s2 uni) (x uni))
      (= (mem1 a x (union1 a s1 s2)) (or (mem1 a x s1) (mem1 a x s2))))))

;; "subset_union_1"
(assert
  (forall ((a ty))
    (forall ((s1 uni) (s2 uni)) (subset1 a s1 (union1 a s1 s2)))))

;; "subset_union_2"
(assert
  (forall ((a ty))
    (forall ((s1 uni) (s2 uni)) (subset1 a s2 (union1 a s1 s2)))))

;; "inter"
(declare-fun inter (ty
  uni
  uni) uni)

;; "inter_sort"
(assert
  (forall ((a ty))
    (forall ((x uni) (x1 uni)) (sort (fset1 a) (inter a x x1)))))

;; "inter_def"
(assert
  (forall ((s1 (fset vertex)) (s2 (fset vertex)) (x vertex))
    (=
      (mem2 x (tb2t (inter vertex1 (t2tb s1) (t2tb s2))))
      (and (mem2 x s1) (mem2 x s2)))))

;; "inter_def"
(assert
  (forall ((a ty))
    (forall ((s1 uni) (s2 uni) (x uni))
      (= (mem1 a x (inter a s1 s2)) (and (mem1 a x s1) (mem1 a x s2))))))

;; "subset_inter_1"
(assert
  (forall ((a ty))
    (forall ((s1 uni) (s2 uni)) (subset1 a (inter a s1 s2) s1))))

;; "subset_inter_2"
(assert
  (forall ((a ty))
    (forall ((s1 uni) (s2 uni)) (subset1 a (inter a s1 s2) s2))))

;; "diff"
(declare-fun diff (ty
  uni
  uni) uni)

;; "diff_sort"
(assert
  (forall ((a ty))
    (forall ((x uni) (x1 uni)) (sort (fset1 a) (diff a x x1)))))

;; "diff_def"
(assert
  (forall ((s1 (fset vertex)) (s2 (fset vertex)) (x vertex))
    (=
      (mem2 x (tb2t (diff vertex1 (t2tb s1) (t2tb s2))))
      (and (mem2 x s1) (not (mem2 x s2))))))

;; "diff_def"
(assert
  (forall ((a ty))
    (forall ((s1 uni) (s2 uni) (x uni))
      (= (mem1 a x (diff a s1 s2)) (and (mem1 a x s1) (not (mem1 a x s2)))))))

;; "subset_diff"
(assert
  (forall ((a ty))
    (forall ((s1 uni) (s2 uni)) (subset1 a (diff a s1 s2) s1))))

;; "pick"
(declare-fun pick (ty
  uni) uni)

;; "pick_sort"
(assert (forall ((a ty)) (forall ((x uni)) (sort a (pick a x)))))

;; "pick_def"
(assert
  (forall ((s (fset vertex)))
    (=>
      (not (is_empty vertex1 (t2tb s)))
      (mem2 (tb2t1 (pick vertex1 (t2tb s))) s))))

;; "pick_def"
(assert
  (forall ((a ty))
    (forall ((s uni)) (=> (not (is_empty a s)) (mem1 a (pick a s) s)))))

;; "disjoint"
(declare-fun disjoint (ty
  uni
  uni) Bool)

;; "disjoint'def"
(assert
  (forall ((s1 (fset vertex)) (s2 (fset vertex)))
    (=
      (disjoint vertex1 (t2tb s1) (t2tb s2))
      (forall ((x vertex)) (or (not (mem2 x s1)) (not (mem2 x s2)))))))

;; "disjoint'def"
(assert
  (forall ((a ty))
    (forall ((s1 uni) (s2 uni))
      (and
        (=>
          (disjoint a s1 s2)
          (forall ((x uni)) (or (not (mem1 a x s1)) (not (mem1 a x s2)))))
        (=>
          (forall ((x uni))
            (=> (sort a x) (or (not (mem1 a x s1)) (not (mem1 a x s2)))))
          (disjoint a s1 s2))))))

;; "disjoint_inter_empty"
(assert
  (forall ((a ty))
    (forall ((s1 uni) (s2 uni))
      (= (disjoint a s1 s2) (is_empty a (inter a s1 s2))))))

;; "disjoint_diff_eq"
(assert
  (forall ((a ty))
    (forall ((s1 uni) (s2 uni))
      (=> (sort (fset1 a) s1) (= (disjoint a s1 s2) (= (diff a s1 s2) s1))))))

;; "disjoint_diff_s2"
(assert
  (forall ((a ty))
    (forall ((s1 uni) (s2 uni)) (disjoint a (diff a s1 s2) s2))))

;; "infix @"
(declare-fun infix_at (ty
  ty
  uni
  uni) uni)

;; "infix @_sort"
(assert
  (forall ((a ty) (b ty))
    (forall ((x uni) (x1 uni)) (sort b (infix_at b a x x1)))))

;; "filter"
(declare-fun filter (ty
  uni
  uni) uni)

;; "filter_sort"
(assert
  (forall ((a ty))
    (forall ((x uni) (x1 uni)) (sort (fset1 a) (filter a x x1)))))

;; "t2tb"
(declare-fun t2tb2 (Bool) uni)

;; "t2tb_sort"
(assert (forall ((x Bool)) (sort bool (t2tb2 x))))

;; "tb2t"
(declare-fun tb2t2 (uni) Bool)

;; "BridgeL"
(assert
  (forall ((i Bool)) (! (= (tb2t2 (t2tb2 i)) i) :pattern ((t2tb2 i)) )))

;; "BridgeR"
(assert
  (forall ((j uni))
    (! (=> (sort bool j) (= (t2tb2 (tb2t2 j)) j)) :pattern ((t2tb2 (tb2t2 j))) )))

;; "t2tb"
(declare-fun t2tb3 ((Array vertex Bool)) uni)

;; "t2tb_sort"
(assert
  (forall ((x (Array vertex Bool)))
    (sort (infix_mngt vertex1 bool) (t2tb3 x))))

;; "tb2t"
(declare-fun tb2t3 (uni) (Array vertex Bool))

;; "BridgeL"
(assert
  (forall ((i (Array vertex Bool)))
    (! (= (tb2t3 (t2tb3 i)) i) :pattern ((t2tb3 i)) )))

;; "BridgeR"
(assert
  (forall ((j uni))
    (! (=> (sort (infix_mngt vertex1 bool) j) (= (t2tb3 (tb2t3 j)) j)) :pattern (
    (t2tb3
      (tb2t3 j))) )))

;; "filter_def"
(assert
  (forall ((s (fset vertex)) (p (Array vertex Bool)) (x vertex))
    (=
      (mem2 x (tb2t (filter vertex1 (t2tb s) (t2tb3 p))))
      (and
        (mem2 x s)
        (= (tb2t2 (infix_at bool vertex1 (t2tb3 p) (t2tb1 x))) true)))))

;; "filter_def"
(assert
  (forall ((a ty))
    (forall ((s uni) (p uni) (x uni))
      (=
        (mem1 a x (filter a s p))
        (and (mem1 a x s) (= (tb2t2 (infix_at bool a p x)) true))))))

;; "subset_filter"
(assert
  (forall ((a ty)) (forall ((s uni) (p uni)) (subset1 a (filter a s p) s))))

;; "map"
(declare-fun map1 (ty
  ty
  uni
  uni) uni)

;; "map_sort"
(assert
  (forall ((a ty) (b ty))
    (forall ((x uni) (x1 uni)) (sort (fset1 b) (map1 b a x x1)))))

;; "map_def"
(assert
  (forall ((a ty))
    (forall ((f uni) (u uni) (y vertex))
      (and
        (=>
          (mem2 y (tb2t (map1 vertex1 a f u)))
          (exists ((x uni))
            (and
              (sort a x)
              (and (mem1 a x u) (= y (tb2t1 (infix_at vertex1 a f x)))))))
        (=>
          (exists ((x uni))
            (and (mem1 a x u) (= y (tb2t1 (infix_at vertex1 a f x)))))
          (mem2 y (tb2t (map1 vertex1 a f u))))))))

;; "t2tb"
(declare-fun t2tb4 ((Array vertex vertex)) uni)

;; "t2tb_sort"
(assert
  (forall ((x (Array vertex vertex)))
    (sort (infix_mngt vertex1 vertex1) (t2tb4 x))))

;; "tb2t"
(declare-fun tb2t4 (uni) (Array vertex vertex))

;; "BridgeL"
(assert
  (forall ((i (Array vertex vertex)))
    (! (= (tb2t4 (t2tb4 i)) i) :pattern ((t2tb4 i)) )))

;; "BridgeR"
(assert
  (forall ((j uni))
    (! (=> (sort (infix_mngt vertex1 vertex1) j) (= (t2tb4 (tb2t4 j)) j)) :pattern (
    (t2tb4
      (tb2t4 j))) )))

;; "map_def"
(assert
  (forall ((f (Array vertex vertex)) (u (fset vertex)) (y vertex))
    (=
      (mem2 y (tb2t (map1 vertex1 vertex1 (t2tb4 f) (t2tb u))))
      (exists ((x vertex))
        (and
          (mem2 x u)
          (= y (tb2t1 (infix_at vertex1 vertex1 (t2tb4 f) (t2tb1 x)))))))))

;; "map_def"
(assert
  (forall ((b ty))
    (forall ((f uni) (u (fset vertex)) (y uni))
      (=>
        (sort b y)
        (=
          (mem1 b y (map1 b vertex1 f (t2tb u)))
          (exists ((x vertex))
            (and (mem2 x u) (= y (infix_at b vertex1 f (t2tb1 x))))))))))

;; "map_def"
(assert
  (forall ((a ty) (b ty))
    (forall ((f uni) (u uni) (y uni))
      (=>
        (sort b y)
        (and
          (=>
            (mem1 b y (map1 b a f u))
            (exists ((x uni))
              (and (sort a x) (and (mem1 a x u) (= y (infix_at b a f x))))))
          (=>
            (exists ((x uni)) (and (mem1 a x u) (= y (infix_at b a f x))))
            (mem1 b y (map1 b a f u))))))))

;; "mem_map"
(assert
  (forall ((a ty))
    (forall ((f uni) (u uni))
      (forall ((x uni))
        (=>
          (mem1 a x u)
          (mem2 (tb2t1 (infix_at vertex1 a f x)) (tb2t (map1 vertex1 a f u))))))))

;; "mem_map"
(assert
  (forall ((f (Array vertex vertex)) (u (fset vertex)))
    (forall ((x vertex))
      (=>
        (mem2 x u)
        (mem2
          (tb2t1 (infix_at vertex1 vertex1 (t2tb4 f) (t2tb1 x)))
          (tb2t (map1 vertex1 vertex1 (t2tb4 f) (t2tb u))))))))

;; "mem_map"
(assert
  (forall ((b ty))
    (forall ((f uni) (u (fset vertex)))
      (forall ((x vertex))
        (=>
          (mem2 x u)
          (mem1
            b
            (infix_at b vertex1 f (t2tb1 x))
            (map1 b vertex1 f (t2tb u))))))))

;; "mem_map"
(assert
  (forall ((a ty) (b ty))
    (forall ((f uni) (u uni))
      (forall ((x uni))
        (=> (mem1 a x u) (mem1 b (infix_at b a f x) (map1 b a f u)))))))

;; "cardinal"
(declare-fun cardinal (ty
  uni) Int)

;; "cardinal_nonneg"
(assert (forall ((a ty)) (forall ((s uni)) (<= 0 (cardinal a s)))))

;; "cardinal_empty"
(assert
  (forall ((a ty))
    (forall ((s uni)) (= (is_empty a s) (= (cardinal a s) 0)))))

;; "cardinal_add"
(assert
  (forall ((x vertex))
    (forall ((s (fset vertex)))
      (ite (mem2 x s)
        (= (cardinal vertex1 (add vertex1 (t2tb1 x) (t2tb s))) (cardinal
                                                                 vertex1
                                                                 (t2tb s)))
        (= (cardinal vertex1 (add vertex1 (t2tb1 x) (t2tb s))) (+ (cardinal
                                                                    vertex1
                                                                    (t2tb s)) 1))))))

;; "cardinal_add"
(assert
  (forall ((a ty))
    (forall ((x uni))
      (forall ((s uni))
        (ite (mem1 a x s)
          (= (cardinal a (add a x s)) (cardinal a s))
          (= (cardinal a (add a x s)) (+ (cardinal a s) 1)))))))

;; "cardinal_remove"
(assert
  (forall ((x vertex))
    (forall ((s (fset vertex)))
      (ite (mem2 x s)
        (= (cardinal vertex1 (remove vertex1 (t2tb1 x) (t2tb s))) (- 
        (cardinal
          vertex1
          (t2tb s)) 1))
        (= (cardinal vertex1 (remove vertex1 (t2tb1 x) (t2tb s))) (cardinal
                                                                    vertex1
                                                                    (t2tb s)))))))

;; "cardinal_remove"
(assert
  (forall ((a ty))
    (forall ((x uni))
      (forall ((s uni))
        (ite (mem1 a x s)
          (= (cardinal a (remove a x s)) (- (cardinal a s) 1))
          (= (cardinal a (remove a x s)) (cardinal a s)))))))

;; "cardinal_subset"
(assert
  (forall ((a ty))
    (forall ((s1 uni) (s2 uni))
      (=> (subset1 a s1 s2) (<= (cardinal a s1) (cardinal a s2))))))

;; "subset_eq"
(assert
  (forall ((a ty))
    (forall ((s1 uni) (s2 uni))
      (=>
        (sort (fset1 a) s1)
        (=>
          (sort (fset1 a) s2)
          (=>
            (subset1 a s1 s2)
            (=> (= (cardinal a s1) (cardinal a s2)) (= s1 s2))))))))

;; "cardinal1"
(assert
  (forall ((s (fset vertex)))
    (=>
      (= (cardinal vertex1 (t2tb s)) 1)
      (forall ((x vertex))
        (=> (mem2 x s) (= x (tb2t1 (pick vertex1 (t2tb s)))))))))

;; "cardinal1"
(assert
  (forall ((a ty))
    (forall ((s uni))
      (=>
        (= (cardinal a s) 1)
        (forall ((x uni)) (=> (sort a x) (=> (mem1 a x s) (= x (pick a s)))))))))

;; "cardinal_union"
(assert
  (forall ((a ty))
    (forall ((s1 uni) (s2 uni))
      (= (cardinal a (union1 a s1 s2)) (- (+ (cardinal a s1) (cardinal a s2)) 
      (cardinal
        a
        (inter a s1 s2)))))))

;; "cardinal_inter_disjoint"
(assert
  (forall ((a ty))
    (forall ((s1 uni) (s2 uni))
      (=> (disjoint a s1 s2) (= (cardinal a (inter a s1 s2)) 0)))))

;; "cardinal_diff"
(assert
  (forall ((a ty))
    (forall ((s1 uni) (s2 uni))
      (= (cardinal a (diff a s1 s2)) (- (cardinal a s1) (cardinal
                                                          a
                                                          (inter a s1 s2)))))))

;; "cardinal_filter"
(assert
  (forall ((a ty))
    (forall ((s uni) (p uni))
      (<= (cardinal a (filter a s p)) (cardinal a s)))))

;; "cardinal_map"
(assert
  (forall ((a ty) (b ty))
    (forall ((f uni) (s uni))
      (<= (cardinal b (map1 b a f s)) (cardinal a s)))))

;; "to_fset"
(declare-fun to_fset (set) (fset vertex))

;; "v"
(declare-fun v () (fset vertex))

;; "g_succ"
(declare-fun g_succ (vertex) (fset vertex))

;; "g_succ'spec"
(assert
  (forall ((usx vertex)) (subset1 vertex1 (t2tb (g_succ usx)) (t2tb v))))

;; "weight"
(declare-fun weight (vertex
  vertex) Int)

;; "weight'spec"
(assert (forall ((us vertex) (us1 vertex)) (< 0 (weight us us1))))

;; "path"
(declare-fun path (vertex
  vertex
  Int) Bool)

;; "Path_nil"
(assert (forall ((x vertex)) (path x x 0)))

;; "Path_cons"
(assert
  (forall ((x vertex) (y vertex) (a vertex) (b vertex))
    (forall ((d1 Int) (d2 Int))
      (=>
        (path x y d1)
        (=>
          (path a b d2)
          (=> (mem2 a (g_succ y)) (path x b (+ (+ d1 (weight y a)) d2))))))))

;; "path_inversion"
(assert
  (forall ((z vertex) (z1 vertex) (z2 Int))
    (=>
      (path z z1 z2)
      (or
        (and (= z1 z) (= z2 0))
        (exists ((y vertex) (a vertex))
          (exists ((d1 Int) (d2 Int))
            (and
              (path z y d1)
              (and
                (path a z1 d2)
                (and (mem2 a (g_succ y)) (= z2 (+ (+ d1 (weight y a)) d2)))))))))))

;; "shortest_path"
(declare-fun shortest_path (vertex
  vertex
  Int) Bool)

;; "shortest_path'def"
(assert
  (forall ((x vertex) (y vertex) (d Int))
    (=
      (shortest_path x y d)
      (and (path x y d) (forall ((dqt Int)) (=> (path x y dqt) (<= d dqt)))))))

;; "Length_nonneg"
(assert
  (forall ((x vertex) (y vertex))
    (forall ((d Int)) (=> (path x y d) (<= 0 d)))))

;; "Shortest_length_nonneg"
(assert
  (forall ((x vertex) (y vertex))
    (forall ((d Int)) (=> (shortest_path x y d) (<= 0 d)))))

;; "Path_one_step"
(assert
  (forall ((a vertex) (b vertex))
    (=> (mem2 b (g_succ a)) (path a b (weight a b)))))

;; "Path_append"
(assert
  (forall ((src vertex) (u vertex) (v1 vertex) (d Int))
    (=>
      (path src v1 d)
      (=> (mem2 u (g_succ v1)) (path src u (+ d (weight v1 u)))))))

;; "Path_inversion"
(assert
  (forall ((src vertex) (v1 vertex))
    (forall ((d Int))
      (=>
        (path src v1 d)
        (or
          (and (= v1 src) (= d 0))
          (exists ((vqt vertex))
            (and (path src vqt (- d (weight vqt v1))) (mem2 v1 (g_succ vqt)))))))))

;; "Path_shortest_path"
(assert
  (forall ((src vertex) (v1 vertex))
    (forall ((d Int))
      (=>
        (path src v1 d)
        (exists ((dqt Int)) (and (shortest_path src v1 dqt) (<= dqt d)))))))

;; "shortest_path_to_self"
(assert (forall ((v1 vertex) (d Int)) (=> (shortest_path v1 v1 d) (= d 0))))

;; "left_extend"
(assert
  (forall ((x vertex) (y vertex) (z vertex))
    (forall ((d Int))
      (=>
        (path y z d)
        (=> (mem2 y (g_succ x)) (path x z (+ d (weight x y))))))))

;; "right_extend"
(assert
  (forall ((x vertex) (y vertex) (z vertex))
    (forall ((d Int))
      (=>
        (path x y d)
        (=> (mem2 z (g_succ y)) (path x z (+ d (weight y z))))))))

;; "path_inversion_left"
(assert
  (forall ((src vertex) (v1 vertex))
    (forall ((d Int))
      (=>
        (path src v1 d)
        (or
          (and (= v1 src) (= d 0))
          (exists ((vqt vertex))
            (and
              (path vqt v1 (- d (weight src vqt)))
              (mem2 vqt (g_succ src)))))))))

;; "optimal_substructure"
(assert
  (forall ((a vertex) (b vertex) (d Int))
    (=>
      (shortest_path a b d)
      (or
        (and (= a b) (= d 0))
        (and
          (exists ((c vertex))
            (and (mem2 b (g_succ c)) (shortest_path a c (- d (weight c b)))))
          (exists ((c vertex))
            (and (mem2 c (g_succ a)) (shortest_path c b (- d (weight a c))))))))))

;; "path_splitting"
(assert
  (forall ((a vertex) (b vertex) (d Int))
    (=>
      (shortest_path a b d)
      (exists ((c vertex) (dqt Int))
        (and (shortest_path a c dqt) (shortest_path c b (- d dqt)))))))

;; "path_splitting_noneq"
(assert
  (forall ((a vertex) (b vertex) (d Int))
    (=>
      (shortest_path a b d)
      (=>
        (not (= a b))
        (exists ((x vertex) (y vertex) (dqt Int))
          (and
            (mem2 y (g_succ x))
            (and
              (shortest_path a x dqt)
              (shortest_path y b (- (- d dqt) (weight x y))))))))))

;; "path_merging"
(assert
  (forall ((a vertex) (b vertex) (c vertex) (d1 Int) (d2 Int))
    (=> (path a b d1) (=> (path b c d2) (path a c (+ d2 d1))))))

;; "subpath_optimality_constraint"
(assert
  (forall ((a vertex) (b vertex) (c vertex) (d Int) (dqt Int))
    (=>
      (shortest_path a c d)
      (=>
        (path a b dqt)
        (=>
          (path b c (- d dqt))
          (and (shortest_path a b dqt) (shortest_path b c (- d dqt))))))))

;; "admissible"
(declare-fun admissible ((Array vertex Int)
  vertex) Bool)

;; "t2tb"
(declare-fun t2tb5 (Int) uni)

;; "t2tb_sort"
(assert (forall ((x Int)) (sort int (t2tb5 x))))

;; "tb2t"
(declare-fun tb2t5 (uni) Int)

;; "BridgeL"
(assert (forall ((i Int)) (! (= (tb2t5 (t2tb5 i)) i) :pattern ((t2tb5 i)) )))

;; "BridgeR"
(assert
  (forall ((j uni))
    (! (= (t2tb5 (tb2t5 j)) j) :pattern ((t2tb5 (tb2t5 j))) )))

;; "t2tb"
(declare-fun t2tb6 ((Array vertex Int)) uni)

;; "t2tb_sort"
(assert
  (forall ((x (Array vertex Int))) (sort (infix_mngt vertex1 int) (t2tb6 x))))

;; "tb2t"
(declare-fun tb2t6 (uni) (Array vertex Int))

;; "BridgeL"
(assert
  (forall ((i (Array vertex Int)))
    (! (= (tb2t6 (t2tb6 i)) i) :pattern ((t2tb6 i)) )))

;; "BridgeR"
(assert
  (forall ((j uni))
    (! (= (t2tb6 (tb2t6 j)) j) :pattern ((t2tb6 (tb2t6 j))) )))

;; "admissible'def"
(assert
  (forall ((f (Array vertex Int)) (dst vertex))
    (=
      (admissible f dst)
      (forall ((src vertex) (d Int))
        (=>
          (path src dst d)
          (<= (tb2t5 (infix_at int vertex1 (t2tb6 f) (t2tb1 src))) d))))))

;; "consistent"
(declare-fun consistent ((Array vertex Int)
  vertex) Bool)

;; "consistent'def"
(assert
  (forall ((f (Array vertex Int)) (dst vertex))
    (=
      (consistent f dst)
      (and
        (= (tb2t5 (infix_at int vertex1 (t2tb6 f) (t2tb1 dst))) 0)
        (forall ((a vertex) (b vertex) (d Int))
          (=>
            (path a b d)
            (<= (tb2t5 (infix_at int vertex1 (t2tb6 f) (t2tb1 a))) (+ d 
            (tb2t5
              (infix_at int vertex1 (t2tb6 f) (t2tb1 b)))))))))))

;; "consistent_implies_admissible"
(assert
  (forall ((dst vertex) (f (Array vertex Int)))
    (=>
      (forall ((n vertex))
        (<= 0 (tb2t5 (infix_at int vertex1 (t2tb6 f) (t2tb1 n)))))
      (=> (consistent f dst) (admissible f dst)))))

;; "Main_lemma"
(assert
  (forall ((src vertex) (v1 vertex))
    (forall ((d Int))
      (=>
        (path src v1 d)
        (=>
          (not (shortest_path src v1 d))
          (or
            (and (= v1 src) (< 0 d))
            (and
              (exists ((vqt vertex))
                (exists ((dqt Int))
                  (and
                    (shortest_path src vqt dqt)
                    (and
                      (mem2 v1 (g_succ vqt))
                      (< (+ dqt (weight vqt v1)) d)))))
              (exists ((vqt vertex))
                (exists ((dqt Int))
                  (and
                    (shortest_path vqt v1 dqt)
                    (and
                      (mem2 vqt (g_succ src))
                      (< (+ dqt (weight src vqt)) d))))))))))))

;; "Completeness_lemma"
(assert
  (forall ((s set))
    (=>
      (forall ((v1 vertex))
        (=>
          (mem2 v1 (to_fset s))
          (forall ((w vertex))
            (=> (mem2 w (g_succ v1)) (mem2 w (to_fset s))))))
      (forall ((src vertex))
        (=>
          (mem2 src (to_fset s))
          (forall ((dst vertex))
            (forall ((d Int)) (=> (path src dst d) (mem2 dst (to_fset s))))))))))

;; "inside_or_exit_1"
(assert
  (forall ((s (fset vertex)) (src vertex) (v1 vertex) (d Int))
    (=>
      (mem2 src s)
      (=>
        (path src v1 d)
        (=>
          (not (mem2 v1 s))
          (exists ((y vertex))
            (exists ((z vertex))
              (exists ((dy Int))
                (and
                  (mem2 y s)
                  (and
                    (not (mem2 z s))
                    (and
                      (mem2 z (g_succ y))
                      (and
                        (path src y dy)
                        (and
                          (path src z (+ dy (weight y z)))
                          (path z v1 (- d (+ dy (weight y z)))))))))))))))))

;; "inside_or_exit_2"
(assert
  (forall ((s (fset vertex)) (src vertex) (v1 vertex) (d Int))
    (=>
      (mem2 src s)
      (=>
        (path src v1 d)
        (=>
          (not (mem2 v1 s))
          (exists ((y vertex))
            (exists ((z vertex))
              (exists ((dz Int))
                (and
                  (mem2 y s)
                  (and
                    (not (mem2 z s))
                    (and
                      (mem2 z (g_succ y))
                      (and
                        (path src y (- dz (weight y z)))
                        (and (path src z dz) (path z v1 (- d dz)))))))))))))))

;; Goal "inside_or_exit"
;; File "/Users/kajetanneumann/Desktop/Research Project/Why3-A-Star/Dijkstra/dijkstra.mlw", line 306, characters 8-22
(assert
  (not
  (forall ((s (fset vertex)) (src vertex) (v1 vertex) (d Int))
    (=>
      (mem2 src s)
      (=>
        (shortest_path src v1 d)
        (=>
          (not (mem2 v1 s))
          (exists ((y vertex) (z vertex) (dz Int))
            (and
              (mem2 y s)
              (and
                (not (mem2 z s))
                (and
                  (mem2 z (g_succ y))
                  (and
                    (shortest_path src y (- dz (weight y z)))
                    (and
                      (shortest_path src z dz)
                      (shortest_path z v1 (- d dz))))))))))))))

(check-sat)
