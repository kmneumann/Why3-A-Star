
(* Dijkstra's shortest path algorithm.

   This proof follows Cormen et al's "Algorithms".

   Author: Jean-Christophe Filli√¢tre (CNRS) *)

module ImpmapNoDom

  use map.Map
  use map.Const

  type key

  type t 'a = abstract { mutable contents: map key 'a }

  val function create (x: 'a): t 'a
    ensures { result.contents = const x }

  val function ([]) (m: t 'a) (k: key): 'a
    ensures { result = m.contents[k] }

  val ghost function ([<-]) (m: t 'a) (k: key) (v: 'a): t 'a
    ensures { result.contents = m.contents[k <- v] }

  val ([]<-) (m: t 'a) (k: key) (v: 'a): unit
    writes { m }
    ensures { m = (old m)[k <- v] }

end



module GraphDef
  
  use int.Int
  use list.List
  use list.Append
  use option.Option
  
  type vertex = int
  
  clone graph.IntPathWeight with type vertex = vertex
  clone set.SetImp with type elt = vertex
  
  constant graph: fset vertex
  
  axiom Positive_weight: forall a, b. weight a b > 0
  axiom Non_self_edges: forall a. not edge a a
  
  predicate shortest_path (a: vertex) (l: list vertex) (b: vertex) = 
    path a l b /\ 
    (forall l'. path a l' b -> path_weight l b <= path_weight l' b)
  
  val ghost function successors (x: vertex): fset vertex
    ensures { forall n. mem n result <-> edge x n }
  
  val successors_impl (x: vertex): set
    ensures { result = successors x }
  
  predicate closed_under_succ (v: fset vertex) = 
    forall n. mem n v -> forall m. edge n m -> mem m v
  
  lemma path_nonneg: 
    forall x, y, l. path x l y -> path_weight l y >= 0
  
  lemma shortest_path_nonneg: 
    forall x, y, l. shortest_path x l y -> path_weight l y >= 0
  
  lemma shortest_path_decomposition:
    forall x y z: vertex, l1 l2: list vertex.
    shortest_path x (l1 ++ Cons y l2) z -> shortest_path x l1 y /\ shortest_path y (Cons y l2) z
  
  lemma shortest_path_negation:
    forall a, b, l. not (shortest_path a l b) ->
    not (path a l b) \/ (exists l'. path a l' b /\ path_weight l' b < path_weight l b)
  
  lemma path_weight_sub_path:
    forall x y z: vertex, l1 l2 l3: list vertex.
    path_weight (l1 ++ (Cons x l2) ++ (Cons y l3)) z =
    path_weight l1 x + path_weight (Cons x l2) y + path_weight (Cons y l3) z
  
  lemma optimal_substructure_property:
    forall s, t, a, b, l1, l2, l_ab. 
    shortest_path s (l1 ++ (Cons a l_ab) ++ (Cons b l2)) t -> 
    shortest_path a (Cons a l_ab) b
  
  lemma sub_path:
    forall x, a, b, z, l1, l2.
        path x l1 a -> path b l2 z -> edge a b -> path x (l1 ++ (Cons a l2)) z
  
  lemma sub_path_inversion:
    forall x z: vertex, l: list vertex. path x l z ->
       (x = z /\ l = Nil)
    \/ (exists a, b, l1, l2.
        path x l1 a /\ path b l2 z /\ edge a b /\ l = l1 ++ (Cons a l2))
  
  lemma inside_or_exit_path:
    forall s, src, v, l. mem src s -> path src l v -> not (mem v s) ->
      (exists y, z, l1, l2.
        mem y s /\ not (mem z s) /\ edge y z /\
        path src l1 y /\ path z l2 v /\ l = l1 ++ Cons y l2)
  
  lemma inside_or_exit_shortest_path:
    forall s, src, v, l. mem src s -> shortest_path src l v -> not (mem v s) ->
      (exists y, z, l1, l2.
        mem y s /\ not (mem z s) /\ edge y z /\
        shortest_path src l1 y /\ shortest_path z l2 v /\ l = l1 ++ Cons y l2)
  
  predicate path_existance (a b: vertex) =
    exists d, l. path a l b /\ path_weight l b = d
  
  lemma path_imples_exists_shortest_path:
    forall a, b, l. path a l b -> (exists l'. path_weight l' b <= path_weight l b /\ shortest_path a l' b)
  
  lemma path_zero:
    forall a, b, l. path a l b -> path_weight l b = 0 -> l = Nil /\ a = b
  
  lemma main_lemma:
    forall src v: vertex. forall l: list vertex.
    path src l v -> not (shortest_path src l v) ->
    v = src /\ l <> Nil
    \/
    (exists v': vertex. exists l': list vertex. shortest_path v' l' v /\ edge src v' /\ path_weight (Cons src l') v < path_weight l v)
  
  lemma completeness_lemma:
    forall s: set.
    (* if s is closed under g_succ *)
    closed_under_succ s ->
    (* and if s contains src *)
    forall src: vertex. mem src s ->
    (* then any vertex reachable from s is also in s *)
    forall dst, l.
    path src l dst -> mem dst s
  
  predicate path_with_len (a b: vertex) (d: int) = 
    exists l. path a l b /\ (path_weight l b = d)
  
  predicate shortest_path_with_len (a b: vertex) (d: int) = 
    exists l. shortest_path a l b /\ (path_weight l b = d)
  
  
  (* Admissibility & Consistency *)
  
  predicate positive (f: vertex -> int) = 
    (forall n. f n >= 0)
  
  predicate consistent (f: vertex -> int) (dst: vertex) = 
    f dst = 0 /\
    (forall a b:vertex.
      edge a b ->
      f a <= weight a b + f b )
  
  predicate path_consistent (f: vertex -> int) (dst: vertex) = 
    f dst = 0 /\
    (forall a b:vertex, l: list vertex.
      path a l b ->
      f a <= path_weight l b + f b )
  
  predicate admissible (f: vertex -> int) (dst: vertex) = 
    forall a, l. path a l dst -> f a <= path_weight l dst
  
  lemma consistent_implies_admissible:
    forall dst: vertex, f: (vertex -> int). positive f -> consistent f dst -> admissible f dst
  
  lemma consistent_implies_path_consistent:
    forall dst: vertex, f: (vertex -> int). positive f -> consistent f dst -> path_consistent f dst
  
  
  
  (* Distance Map & Previous Map *)
  clone ImpmapNoDom with type key = vertex
  
  val closed: set
  val open: set
  val p: t (list vertex)
  val d: t int
  
  predicate min (m: vertex) (q: set) (d: t int) (h: vertex -> int) =
    mem m q /\
    (forall x: vertex. mem x q -> d[m] + h m <= d[x] + h x)

  val q_extract_min (h: vertex -> int) : vertex 
    writes   { open }
    requires { not is_empty open }
    ensures  { min result (old open) d h }
    ensures  { open = remove result (old open) }
    
  predicate inv_src (src: vertex) (s q: set) =
    mem src s \/ mem src q

  predicate inv (src: vertex) (s q: set) (d: t int) =
    inv_src src s q /\ d[src] = 0 /\
    (* S and Q are contained in V *)
    subset s graph /\ subset q graph /\
    (* S and Q are disjoint *)
    disjoint s q /\
    (* we already found the shortest paths for vertices in S *)
    (forall v: vertex. mem v s -> shortest_path_with_len src v d[v]) /\
    (* there are paths for vertices in Q *)
    (forall n. mem n q \/ mem n s -> path_with_len src n d[n]) /\
    (forall n. mem n q -> (exists u. mem n (successors u) /\ mem u s /\ d[u] + weight u n = d[n]) \/ n = src) /\
    (forall n. not (mem n q /\ mem n s))

  predicate inv_succ (_src: vertex) (s q: set) (d: t int) =
    (* successors of vertices in S are either in S or in Q *)
    forall x: vertex. mem x s ->
    forall y: vertex. mem y (successors x) ->
    (mem y s \/ mem y q) /\ d[y] <= d[x] + weight x y 

  predicate inv_succ2 (_src: vertex) (s q: set) (d: t int) (u: vertex) (su: set) (h: vertex -> int) =
    (* successors of vertices in S are either in S or in Q,
       unless they are successors of u still in su *)
    forall x: vertex. mem x s ->
    forall y: vertex. mem y (successors x) ->
    (x<>u \/ (x=u /\ not (mem y su))) ->
    (mem y s \/ mem y q) /\ d[y] + h y <= d[x] + weight x y + h y
    

  (* Initialisation of visited, q, and d. *)
  let infinity = any int ensures { forall n. n < result }
  
  val init (src: vertex) : unit 
    writes  { closed, open, d }
    ensures { is_empty closed }
    ensures { open = singleton src }
    ensures { d = (old d)[src <- 0] }
    
  exception Found (list vertex)
  
  let shortest_path_code (src dst: vertex) (h: vertex -> int): option int
    requires { consistent h dst /\ positive h }
    requires { mem src graph /\ mem dst graph }
    returns  { result -> 
      match result with 
      | Some n -> shortest_path_with_len src dst n
      | None -> forall n. not shortest_path_with_len src dst n
      end
     }
  = init src;
    while not is_empty open do
      invariant { inv src closed open d }
      invariant { inv_succ src closed open d }
      invariant { 
          forall n, dist. shortest_path_with_len src n dist -> not (mem n closed) -> 
            (exists u. mem u open /\ shortest_path_with_len src u d[u] /\ shortest_path_with_len u n (dist - d[u]))
        }
      variant   { cardinal graph - cardinal closed }
      let u = q_extract_min h in
      assert { shortest_path_with_len src u d[u] };
      add u closed;
      if eq u dst then return Some d[u];
      let su = successors_impl u in
      while not is_empty su do
        invariant { subset su (successors u) }
        invariant { inv src closed open d  }
        invariant { inv_succ2 src closed open d u su h }
        variant   { cardinal su }
        
        let y = choose_and_remove su in
        let x = d[u] + weight u y in
        if not (mem y open || mem y closed) then begin 
          add y open;
          d[y] <- x
        end else if x < d[y] then begin 
          assert { not mem y closed };
          remove y closed;
          add y open;
          d[y] <- x
        end;
        assert { d[y] <= d[u] + weight u y }
      done
    done;
    assert { forall n, ds. path_with_len src n ds -> mem n closed };
    None
    
  (*use int.Int
  use ref.Ref

  (** The graph is introduced as a set v of vertices and a function g_succ
     returning the successors of a given vertex.
     The weight of an edge is defined independently, using function weight.
     The weight is an integer. *)

  type vertex

  clone set.SetImp with type elt = vertex

  val constant graph: fset vertex 
    
  val ghost function g_succ (x: vertex) : fset vertex
    requires { mem x graph }
    ensures  { subset result graph }
    ensures  { not mem x result }

  val get_succs (x: vertex): set
    ensures { result = g_succ x }

  val function weight (a b: vertex) : int
    requires { mem b (g_succ a) }
    ensures  { result > 0 }

  inductive path vertex vertex int =
    | Path_nil :
        forall x: vertex. mem x graph -> path x x 0
    | Path_cons: 
        forall x y a b: vertex. forall d1 d2: int.
        path x y d1 -> path a b d2 -> mem a (g_succ y) -> path x b (d1 + weight y a + d2)

  predicate shortest_path (x y: vertex) (d: int) =
    path x y d /\ 
    forall d': int. path x y d' -> d <= d'
    
  lemma Length_nonneg: forall x y: vertex, d: int. path x y d -> d >= 0
  
  lemma Shortest_length_nonneg: forall x y: vertex, d: int. shortest_path x y d -> d >= 0
  
  lemma Path_one_step:
    forall a, b. mem b (g_succ a) -> path a b (weight a b)
  
  lemma Path_inversion:
    forall src v: vertex, d:int. path src v d ->
    mem src graph /\ mem v graph /\
    ((v = src /\ d = 0) \/
    (exists a, b, d1, d2. path src a d1 /\ path b v d2 /\ mem b (g_succ a) /\ d = d1 + weight a b + d2))
  
  lemma Path_append:
    forall src, u, v, d. path src v d -> mem u (g_succ v) -> path src u (d + weight v u)

  lemma Path_implies_shortest_path:
    forall src v: vertex. forall d: int. path src v d ->
    exists d': int. shortest_path src v d' /\ d' <= d
    
    
  (* My Stuff *)
              
  lemma left_extend:
      forall x y z: vertex. forall d: int.
          path y z d -> mem y (g_succ x) -> path x z (d + weight x y)
  
  lemma right_extend:
      forall x y z: vertex. forall d: int.
          path x y d -> mem z (g_succ y) -> path x z (d + weight y z)
  
  lemma path_inversion_left:
    forall src v:vertex. forall d:int. path src v d ->
    (v = src /\ d = 0) \/
    (exists v':vertex. path v' v (d - weight src v') /\ mem v' (g_succ src))
  
  lemma optimal_substructure:
      forall a b: vertex, d: int.
          shortest_path a b d -> 
              (a = b /\ d = 0) \/
              (exists c: vertex. mem b (g_succ c) /\ shortest_path a c (d - weight c b)) /\
              (exists c:vertex. mem c (g_succ a) /\ shortest_path c b (d - weight a c))
  
  lemma path_splitting:
      forall a b: vertex, d: int.
          shortest_path a b d ->
              (exists c: vertex, d': int. shortest_path a c d' /\ shortest_path c b (d - d'))
  
  lemma path_splitting_noneq:
      forall a b: vertex, d: int.
          shortest_path a b d -> a <> b ->
              (exists x y: vertex, d': int. mem y (g_succ x) /\ shortest_path a x d' /\ shortest_path y b (d - d' - weight x y))
  
  lemma path_merging:
    forall a, b, c, d1, d2. 
        path a b d1 -> path b c d2 -> path a c (d2 + d1)
  
  lemma subpath_optimality_constraint:
      forall a, b, c, d, d'.
         shortest_path a c d -> path a b d' -> path b c (d - d') -> shortest_path a b d' /\ shortest_path b c (d - d')
  
  lemma Main_lemma:
    forall src v: vertex. forall d: int.
    path src v d -> not (shortest_path src v d) ->
    v = src /\ d > 0
    \/
    (exists v': vertex. exists d': int. shortest_path src v' d' /\ mem v (g_succ v') /\ d' + weight v' v < d) 
    /\ (exists v': vertex. exists d': int. shortest_path v' v d' /\ mem v' (g_succ src) /\ d' + weight src v' < d) (* <- added this *)


  (* Lemmas (requiring induction). *)

  lemma Completeness_lemma:
    forall s: set.
    (* if s is closed under g_succ *)
    (forall v: vertex.
       mem v s -> forall w: vertex. mem w (g_succ v) -> mem w s) ->
    (* and if s contains src *)
    forall src: vertex. mem src s ->
    (* then any vertex reachable from s is also in s *)
    forall dst: vertex. forall d: int.
    path src dst d -> mem dst s

  lemma inside_or_exit_1:
    forall s, src, v, d. mem src s -> path src v d -> not (mem v s) ->
      exists y. exists z. exists dy.
        mem y s /\ not (mem z s) /\ mem z (g_succ y) /\
        path src y dy /\ path src z (dy + weight y z) /\ path z v (d - (dy + weight y z))
  
  lemma inside_or_exit_2:
    forall s, src, v, d. mem src s -> path src v d -> not (mem v s) ->
      exists y. exists z. exists dz.
        mem y s /\ not (mem z s) /\ mem z (g_succ y) /\
        path src y (dz - weight y z) /\ path src z dz /\ path z v (d - dz)
  
  lemma inside_or_exit:
    forall s, src, v, d. mem src s -> shortest_path src v d -> not (mem v s) ->
      (exists y, z, dz.
        mem y s /\ not (mem z s) /\ mem z (g_succ y) /\
        shortest_path src y (dz - weight y z) /\ shortest_path src z dz /\ shortest_path z v (d - dz))
  
  predicate post_cond (o: option int) (src dst : vertex) = 
      (o = None /\ (forall d. not (shortest_path src dst d))) \/
      (forall x. o = Some x -> shortest_path src dst x)
      


  
  predicate og_consistent (f: vertex -> int) (dst: vertex) = 
    f dst = 0 /\
    (forall a b:vertex.
      mem b (g_succ a) ->
      f a <= weight a b + f b )*)
  
end